<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Kaleidoscope Background + Global Slots (with Capture + Gestures)</title>
<style>
  :root{ --fg:#eaf3ff; --muted:#9fb0c9; --line:#2a3146; }
  html,body{margin:0;height:100%;background:#000;color:var(--fg);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial; overflow:hidden}

  /* ===== Kaleidoscope canvas as permanent background ===== */
  #kaleido{
    position:fixed; inset:0; width:100vw; height:100vh; display:block;
    z-index:0; background:#000; touch-action:none; cursor:grab;
  }

  /* ===== Kaleidoscope control panel (no appear button) ===== */
  #kbar{
    position:fixed; left:50%; top:12px; transform:translateX(-50%);
    display:grid; gap:10px; grid-template-columns:repeat(4,minmax(260px,1fr)); /* +1 column for Capture */
    max-width:96vw; max-height:84vh; overflow:auto; padding:12px;
    background:linear-gradient(180deg,rgba(16,18,26,.78),rgba(12,14,20,.65));
    border:1px solid var(--line); border-radius:14px; backdrop-filter:blur(10px);
    z-index:20;
  }
  @media (max-width:1100px){ #kbar{grid-template-columns:repeat(2,minmax(260px,1fr));} }
  @media (max-width:760px){ #kbar{grid-template-columns:1fr;} }

  .card{border:1px solid var(--line); border-radius:12px; background:rgba(8,10,16,.55); padding:10px}
  .title{font-weight:800;margin:0 0 8px}
  .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
  label{display:grid; gap:6px; font-size:13px}
  input[type="range"]{width:100%}

  /* Buttons */
  #hidePanel{
    position:fixed; right:12px; top:12px; z-index:30;
    border:none; border-radius:12px; padding:8px 12px; cursor:pointer; font-weight:800; color:#0a1f14;
    background:linear-gradient(180deg,#B9FFD8,#54F7A9);
    box-shadow:0 0 18px 6px rgba(108,255,178,.45),inset 0 0 0 1px rgba(0,0,0,.15);
  }
  .mintbtn{
    border:none;border-radius:12px;padding:6px 12px;font-weight:800;cursor:pointer;font-size:14px;
    box-shadow:0 0 14px 5px rgba(108,255,178,.35), inset 0 0 0 1px rgba(0,0,0,.15)
  }
  #kSnap{color:#0a1f14;background:linear-gradient(180deg,#B9FFD8,#54F7A9)}
  #kRecStart{color:#fff;background:linear-gradient(180deg,#ff8ba7,#ff3355)}
  #kRecStop{color:#fff;background:linear-gradient(180deg,#9ab6ff,#3344ff)}
  #kRecStop[disabled]{opacity:.5;cursor:not-allowed;box-shadow:none}

  /* ===== Global edge “places” for insert appear buttons ===== */
  .lane{position:fixed;display:grid;gap:8px;pointer-events:none;z-index:50;opacity:.25}
  #lane-top,#lane-bottom{left:6vw;right:6vw;grid-template-columns:repeat(6,1fr)}
  #lane-top{top:10px} #lane-bottom{bottom:10px}
  #lane-left,#lane-right{top:10vh;bottom:10vh;grid-template-rows:repeat(8,1fr)}
  #lane-left{left:10px} #lane-right{right:10px}
  .slot{min-width:56px;min-height:56px;border-radius:10px;display:flex;align-items:center;justify-content:center}
  .appear{
    pointer-events:auto;border:none;border-radius:12px;padding:10px 14px;
    font-size:16px;font-weight:800;display:inline-flex;align-items:center;gap:8px;cursor:pointer;
    color:#0a1f14;background:linear-gradient(180deg,#B9FFD8,#54F7A9);
    box-shadow:0 0 18px 6px rgba(108,255,178,.45), inset 0 0 0 1px rgba(0,0,0,.15);
  }

  /* Example insert overlay should sit on top of kaleido (z-index > 0) */
  .insert-overlay{ position:fixed; inset:0; display:none; place-items:center; z-index:60; }
</style>
</head>
<body>

<!-- Kaleidoscope always-on background -->
<canvas id="kaleido"></canvas>

<!-- Kaleidoscope controls (no appear button; just a hide/show) -->
<button id="hidePanel">Hide Controls</button>
<div id="kbar" aria-label="Kaleidoscope Controls">
  <div class="card">
    <div class="title">Mixer</div>
    <label>Crossfade A ↔ B <input id="mix" type="range" min="0" max="1" step="0.001" value="0.5"></label>
    <div class="row">
      <button id="modeK" class="btn" style="border:1px solid var(--line);border-radius:10px;padding:6px 10px;background:transparent">Kaleidoscope</button>
      <button id="modeM" class="btn" style="border:1px solid var(--line);border-radius:10px;padding:6px 10px;background:transparent">Mirror</button>
    </div>
    <label>Wedges (2–16) <input id="wedges" type="range" min="2" max="16" step="1" value="8"></label>
  </div>

  <div class="card">
    <div class="title">Transform</div>
    <label>Zoom <input id="zoom" type="range" min="0.2" max="6" step="0.001" value="1.0"></label>
    <label>Rotate (scene) <input id="rot" type="range" min="-3.1416" max="3.1416" step="0.0005" value="0"></label>
    <label>Pan X <input id="panx" type="range" min="-1" max="1" step="0.0005" value="0"></label>
    <label>Pan Y <input id="pany" type="range" min="-1" max="1" step="0.0005" value="0"></label>
    <!-- SLOW SPIN: was -2..2 step .01. Now ultra-fine. -->
    <label>Image Spin (rev/s) <input id="spinHz" type="range" min="-0.05" max="0.05" step="0.0001" value="0"></label>
  </div>

  <div class="card">
    <div class="title">Ripple</div>
    <label>Amount <input id="rAmp" type="range" min="0" max="0.6" step="0.001" value="0.20"></label>
    <label>Frequency <input id="rFreq" type="range" min="0.5" max="12" step="0.01" value="6"></label>
    <label>Speed <input id="rSpeed" type="range" min="0" max="6" step="0.01" value="1.5"></label>
  </div>

  <div class="card">
    <div class="title">Decks</div>
    <label>Deck A <input id="pickA" type="file" accept="image/*,video/*"></label>
    <label>Deck B <input id="pickB" type="file" accept="image/*,video/*"></label>
  </div>

  <!-- NEW: Capture -->
  <div class="card">
    <div class="title">Capture</div>
    <div class="row">
      <button id="kSnap" class="mintbtn"> Snapshot</button>
      <button id="kRecStart" class="mintbtn">⏺ Start Rec</button>
      <button id="kRecStop" class="mintbtn" disabled>⏹ Stop</button>
    </div>
    <div style="font-size:12px;opacity:.8;margin-top:6px">Snapshot needs same-origin/CORS. Recording saves a WEBM of the canvas.</div>
  </div>
</div>

<!-- Global edge “places” for insert buttons -->
<div id="lane-top" class="lane"></div>
<div id="lane-bottom" class="lane"></div>
<div id="lane-left" class="lane"></div>
<div id="lane-right" class="lane"></div>

<script>
/* ================= Kaleidoscope background engine ================= */
(() => {
  const $ = id => document.getElementById(id);
  const cv = $('kaleido');
  const UI = {
    mix:$('mix'), wedges:$('wedges'), zoom:$('zoom'), rot:$('rot'),
    panx:$('panx'), pany:$('pany'), rAmp:$('rAmp'), rFreq:$('rFreq'), rSpeed:$('rSpeed'),
    modeK:$('modeK'), modeM:$('modeM'), pickA:$('pickA'), pickB:$('pickB'), spinHz:$('spinHz')
  };
  const state = {
    mix:+UI.mix.value, wedges:+UI.wedges.value, zoom:+UI.zoom.value, rot:+UI.rot.value,
    panx:+UI.panx.value, pany:+UI.pany.value, rAmp:+UI.rAmp.value, rFreq:+UI.rFreq.value, rSpeed:+UI.rSpeed.value,
    spinHz:+UI.spinHz.value, mode:0
  };
  ['mix','wedges','zoom','rot','panx','pany','rAmp','rFreq','rSpeed','spinHz']
    .forEach(k=>UI[k].addEventListener('input', ()=> state[k]=+UI[k].value));
  UI.modeK.onclick = ()=>{ state.mode=0; };
  UI.modeM.onclick = ()=>{ state.mode=1; };

  function fit(){
    const dpr=Math.min(window.devicePixelRatio||1,2);
    const w=Math.floor(innerWidth*dpr), h=Math.floor(innerHeight*dpr);
    if(cv.width!==w||cv.height!==h){ cv.width=w; cv.height=h; }
  }
  addEventListener('resize', fit);

  const deckA = {img:null, vid:null, cvs:document.createElement('canvas'), ctx:null};
  const deckB = {img:null, vid:null, cvs:document.createElement('canvas'), ctx:null};
  deckA.ctx = deckA.cvs.getContext('2d'); deckB.ctx = deckB.cvs.getContext('2d');

  function loadTo(deck, file){
    if(file.type.startsWith('video')){
      const v=document.createElement('video'); v.muted=true; v.loop=true; v.playsInline=true; v.autoplay=true;
      v.onloadeddata=()=>{ v.play().catch(()=>{}); deck.vid=v; deck.img=null; };
      v.src=URL.createObjectURL(file);
    }else{
      const img=new Image();
      img.onload=()=>{ deck.img=img; deck.vid=null; };
      img.src=URL.createObjectURL(file);
    }
  }
  UI.pickA.onchange = e => { const f=e.target.files[0]; if(f) loadTo(deckA,f); e.target.value=''; };
  UI.pickB.onchange = e => { const f=e.target.files[0]; if(f) loadTo(deckB,f); e.target.value=''; };

  // Try WebGL2 → WebGL → Canvas2D
  function tryGL(ver){ try{ return cv.getContext(ver,{preserveDrawingBuffer:true,antialias:true}); }catch{return null;} }
  let gl = tryGL('webgl2') || tryGL('webgl');
  let renderer=null, t0=performance.now();

  if(gl){
    const vs = `
      attribute vec2 aPos; varying vec2 vUv;
      void main(){ vUv=(aPos+1.0)*0.5; gl_Position=vec4(aPos,0.,1.); }
    `;
    const fs = `
      precision highp float; varying vec2 vUv;
      uniform sampler2D texA, texB; uniform float mixAB;
      uniform vec2 resolution; uniform float time;
      uniform int mode; uniform float wedges; uniform float zoom, rot; uniform vec2 pan;
      uniform float rAmp, rFreq, rSpeed; uniform float imgSpin;
      mat2 R(float a){ float c=cos(a), s=sin(a); return mat2(c,-s,s,c); }
      vec2 rotAround(vec2 uv, float a){ vec2 d=uv-0.5; d=R(a)*d; return d+0.5; }
      vec2 userUV(vec2 p){
        vec2 q = R(rot)*p;
        float r = length(q);
        float wave = sin(r*rFreq - time*rSpeed);
        q *= (1.0 + wave * rAmp);
        q *= zoom; q += pan;
        return q*0.5 + 0.5;
      }
      vec3 sampleMix(vec2 uv){
        vec2 suv = rotAround(uv, imgSpin);
        vec4 a=texture2D(texA,suv), b=texture2D(texB,suv);
        return mix(a,b,clamp(mixAB,0.0,1.0)).rgb;
      }
      vec3 kaleido(){
        vec2 n=vUv*2.0-1.0; n.x *= resolution.x/resolution.y;
        float ang=atan(n.y,n.x), r=length(n);
        float sector = 6.28318530718 / max(2.0, wedges);
        float a = mod(ang, sector); if(a>0.5*sector) a = sector - a;
        vec2 dir = vec2(cos(a), sin(a));
        return sampleMix(userUV(r*dir));
      }
      vec3 mirrorFX(){
        vec2 n=vUv*2.0-1.0; n.x *= resolution.x/resolution.y;
        vec2 p = vec2(abs(n.x), n.y);
        return sampleMix(userUV(p));
      }
      void main(){
        vec3 col = (mode==0)? kaleido() : mirrorFX();
        gl_FragColor = vec4(col,1.0);
      }
    `;
    function sh(t,s){const o=gl.createShader(t); gl.shaderSource(o,s); gl.compileShader(o); if(!gl.getShaderParameter(o,gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(o); return o;}
    const pr=gl.createProgram(); gl.attachShader(pr, sh(gl.VERTEX_SHADER,vs)); gl.attachShader(pr, sh(gl.FRAGMENT_SHADER,fs)); gl.linkProgram(pr);
    if(!gl.getProgramParameter(pr,gl.LINK_STATUS)) throw gl.getProgramInfoLog(pr);
    gl.useProgram(pr);

    const quad=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,quad);
    gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1, 1,-1, -1,1, 1,-1, 1,1, -1,1]),gl.STATIC_DRAW);
    const aPos=gl.getAttribLocation(pr,'aPos'); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);

    const U={}; ['texA','texB','mixAB','resolution','time','mode','wedges','zoom','rot','pan','rAmp','rFreq','rSpeed','imgSpin'].forEach(n=>U[n]=gl.getUniformLocation(pr,n));

    function mkTex(){ const t=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,t);
      gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.MIRRORED_REPEAT); gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.MIRRORED_REPEAT);
      const c=document.createElement('canvas'); c.width=c.height=32; const x=c.getContext('2d'); x.fillStyle='#333'; x.fillRect(0,0,32,32); x.fillStyle='#777'; x.fillRect(0,0,16,16);
      gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,c); return t;
    }
    deckA.tex=mkTex(); deckB.tex=mkTex();

    function upload(deck){
      const src=(deck.vid && !deck.vid.paused && !deck.vid.ended)? deck.vid : deck.img; if(!src) return;
      const w=src.videoWidth||src.naturalWidth||src.width, h=src.videoHeight||src.naturalHeight||src.height; if(!w||!h) return;
      deck.cvs.width=w; deck.cvs.height=h; (deck.ctx||=deck.cvs.getContext('2d')).drawImage(src,0,0,w,h);
      gl.bindTexture(gl.TEXTURE_2D, deck.tex); gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,deck.cvs);
    }

    renderer = {
      draw(){
        fit(); upload(deckA); upload(deckB);
        gl.useProgram(pr);
        gl.uniform1i(U.texA,0); gl.uniform1i(U.texB,1);
        gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, deckA.tex);
        gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, deckB.tex);
        gl.uniform2f(U.resolution, cv.width, cv.height);
        const t=(performance.now()-t0)/1000.0;
        gl.uniform1f(U.time, t);
        gl.uniform1i(U.mode, state.mode);
        gl.uniform1f(U.wedges, state.wedges);
        gl.uniform1f(U.zoom, state.zoom);
        gl.uniform1f(U.rot, state.rot);
        gl.uniform2f(U.pan, state.panx, state.pany);
        gl.uniform1f(U.rAmp, state.rAmp);
        gl.uniform1f(U.rFreq, state.rFreq);
        gl.uniform1f(U.rSpeed, state.rSpeed);
        /* SLOW SPIN: tiny spin range in UI; shader multiplies by time */
        gl.uniform1f(U.imgSpin, state.spinHz * 6.28318530718 * t);
        gl.uniform1f(U.mixAB, state.mix);
        gl.viewport(0,0,cv.width,cv.height);
        gl.drawArrays(gl.TRIANGLES,0,6);
      }
    };
  } else {
    // very light 2D fallback
    const ctx2=cv.getContext('2d');
    function draw2D(){
      fit(); ctx2.clearRect(0,0,cv.width,cv.height);
      ctx2.fillStyle='#000'; ctx2.fillRect(0,0,cv.width,cv.height);
    }
    renderer={draw:draw2D};
  }

  function loop(){ renderer.draw(); requestAnimationFrame(loop); }
  fit(); loop();

  // Hide/Show controls
  const hideBtn = document.getElementById('hidePanel');
  const panel   = document.getElementById('kbar');
  hideBtn.addEventListener('click', ()=>{
    const isHidden = panel.style.display==='none';
    panel.style.display = isHidden ? 'grid' : 'none';
    hideBtn.textContent = isHidden ? 'Hide Controls' : 'Show Controls';
  });

  /* ===== Touch: 1-finger pan, 2-finger pinch + twist (restored) ===== */
  const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));
  const pts = new Map(); // id -> {x,y}
  let baseline = { panx:0,pany:0, zoom:1, rot:0, cX:0,cY:0, dist:0, ang:0 };
  function centroid(){ let sx=0,sy=0; for(const p of pts.values()){sx+=p.x; sy+=p.y} const n=pts.size; return {x:sx/n,y:sy/n,n}; }
  function distAng(){ const it=pts.values(); const a=it.next().value, b=it.next().value; const dx=b.x-a.x, dy=b.y-a.y; return {dist:Math.hypot(dx,dy), ang:Math.atan2(dy,dx)}; }
  function snapshotBaseline(){
    baseline.panx=state.panx; baseline.pany=state.pany; baseline.zoom=state.zoom; baseline.rot=state.rot;
    if(pts.size>=2){ const c=centroid(); baseline.cX=c.x; baseline.cY=c.y; const da=distAng(); baseline.dist=da.dist; baseline.ang=da.ang; }
  }
  function syncUI(){ UI.panx.value=state.panx; UI.pany.value=state.pany; UI.zoom.value=state.zoom; UI.rot.value=state.rot; }

  cv.addEventListener('pointerdown', (e)=>{ cv.setPointerCapture(e.pointerId); pts.set(e.pointerId,{x:e.clientX,y:e.clientY}); snapshotBaseline(); }, {passive:false});
  cv.addEventListener('pointermove', (e)=>{
    if(!pts.has(e.pointerId)) return;
    pts.set(e.pointerId,{x:e.clientX,y:e.clientY});
    const c=centroid();
    if(c.n===1){
      // 1-finger pan
      state.panx = clamp(state.panx + (e.movementX/innerWidth)*2, -4, 4);
      state.pany = clamp(state.pany - (e.movementY/innerHeight)*2, -4, 4);
      syncUI();
    } else if (c.n>=2){
      // 2-finger pinch + twist + translate
      const {dist, ang} = distAng();
      const scale = baseline.dist ? (dist / baseline.dist) : 1;
      state.zoom = clamp(baseline.zoom * scale, +UI.zoom.min || 0.2, +UI.zoom.max || 6);
      let dAng = ang - baseline.ang;
      if (dAng > Math.PI)  dAng -= 2*Math.PI;
      if (dAng < -Math.PI) dAng += 2*Math.PI;
      state.rot = clamp(baseline.rot + dAng, +UI.rot.min || -Math.PI, +UI.rot.max || Math.PI);
      state.panx = clamp(baseline.panx + ((c.x - baseline.cX)/innerWidth)*2, -4, 4);
      state.pany = clamp(baseline.pany - ((c.y - baseline.cY)/innerHeight)*2, -4, 4);
      syncUI();
    }
    e.preventDefault();
  }, {passive:false});
  function up(e){ pts.delete(e.pointerId); if(pts.size>0) snapshotBaseline(); }
  cv.addEventListener('pointerup', up, {passive:false});
  cv.addEventListener('pointercancel', up, {passive:false});
  cv.addEventListener('pointerleave', up, {passive:false});
})(); // end kaleidoscope IIFE

/* ================= Global Slots API for inserts ================= */
(() => {
  const lanes = {
    top:    { el: document.getElementById('lane-top'),    count: 6,  prefix:'T' },
    bottom: { el: document.getElementById('lane-bottom'), count: 6,  prefix:'B' },
    left:   { el: document.getElementById('lane-left'),   count: 8,  prefix:'L' },
    right:  { el: document.getElementById('lane-right'),  count: 8,  prefix:'R' },
  };
  const slots = new Map();
  for (const k in lanes){
    const L = lanes[k];
    for (let i=1;i<=L.count;i++){
      const s=document.createElement('div'); s.className='slot'; s.dataset.slotId=`${L.prefix}${i}`;
      L.el.appendChild(s); slots.set(`${L.prefix}${i}`, s);
    }
  }
  function spawnButton(slotId, icon='✨', label='Insert', onClick=()=>{}){
    const slot=slots.get(slotId); if(!slot) return;
    const b=document.createElement('button'); b.className='appear'; b.innerHTML=`<span>${icon}</span><span>${label}</span>`;
    b.onclick=(e)=>{e.stopPropagation(); onClick();}; slot.style.pointerEvents='none'; b.style.pointerEvents='auto';
    slot.innerHTML=''; slot.appendChild(b);
    return b;
  }
  window.AppSlots = { spawnButton }; // inserts can call this
})();

/* ================== Snapshot + Record (canvas capture) ================== */
(() => {
  const cv = document.getElementById('kaleido');
  const btnSnap = document.getElementById('kSnap');
  const btnRecS = document.getElementById('kRecStart');
  const btnRecP = document.getElementById('kRecStop');

  // Snapshot PNG
  if (btnSnap) {
    btnSnap.addEventListener('click', ()=>{
      try{
        const url = cv.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = URL.createObjectURL((()=>{const b64=url.split(',')[1]; const bin=atob(b64); const arr=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++)arr[i]=bin.charCodeAt(i); return new Blob([arr],{type:'image/png'});})());
        a.download = 'kaleidoscope.png'; a.click();
      }catch(e){
        alert('Snapshot failed (CORS if external images without headers).');
        console.error(e);
      }
    });
  }

  // Record WEBM (no audio)
  let stream=null, rec=null, chunks=[];
  function ensureStream(){ if(!stream && cv.captureStream) stream=cv.captureStream(60); return !!stream; }
  if (btnRecS && btnRecP){
    btnRecS.addEventListener('click', ()=>{
      if(!ensureStream()) return alert('canvas.captureStream not supported.');
      if(!('MediaRecorder' in window)) return alert('MediaRecorder not supported.');
      chunks=[];
      try{ rec = new MediaRecorder(stream, { mimeType:'video/webm;codecs=vp9' }); }
      catch{ rec = new MediaRecorder(stream); }
      rec.ondataavailable = e=>{ if(e.data && e.data.size) chunks.push(e.data); };
      rec.onstop = ()=>{
        const blob = new Blob(chunks, { type:'video/webm' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob); a.download='kaleidoscope.webm'; a.click();
        chunks=[];
      };
      rec.start();
      btnRecS.disabled = true; btnRecP.disabled = false;
    });
    btnRecP.addEventListener('click', ()=>{
      try{ if(rec && rec.state!=='inactive') rec.stop(); }catch(e){ console.error(e); }
      btnRecS.disabled = false; btnRecP.disabled = true;
    });
  }
})();
</script>
</body>
</html>
